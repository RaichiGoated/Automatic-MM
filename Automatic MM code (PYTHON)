import discord
from discord.ext import commands, tasks
from discord.ui import Button, View
from discord import Interaction, app_commands
from datetime import datetime, timedelta, timezone
import asyncio
import requests
import json
import math
import random

from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException


rpc_user = 'rpc_user'
rpc_password = 'rpc_password'
rpc_host = 'rpc_host'
rpc_port = 'rpc_port'

# RaiQuick does NOT exist anymore due to expensive hosting.

class ViewPersistence(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix="$", intents=discord.Intents.all(), description="RaiQuick. Your Automatic Middle Man Bot.")

    async def setup_hook(self):
        self.add_view(TicketView123()) 

client = ViewPersistence()
bot = client


@client.event
async def on_ready():
    print(f'We have logged in as {client.user}')
    channel5 = client.get_channel(1234424293476012042)
    if channel5.name == "RaiQuick : ðŸŸ¢":
        pass
    else:
        await channel5.edit(name="RaiQuick : ðŸŸ¢")
    try:
        global rpc_connection
        rpc_connection = AuthServiceProxy(f"http://{rpc_user}:{rpc_password}@{rpc_host}:{rpc_port}")
        print("RPC CONNECTION FINISHED. Waiting for Commands")
    except Exception as e:
        print("Error: ", e)

    try:
        await asyncio.sleep(0.5)
        synced = await client.tree.sync()
        print(f"synced {len(synced)} command(s)")
        print("-------------------")
    except Exception as e:
        print("Error: ", e)
    for guild in bot.guilds:
        await remove_all_members_from_role(guild)
    update_member_count.start()
    check_stats.start()





def read_ticket_counter():
    try:
        with open("ticket_counter.json", "r") as file:
            data = json.load(file)
            return data["ticket_counter"]
    except FileNotFoundError:
        with open("ticket_counter.json", "w") as file:
            json.dump({"ticket_counter": 1}, file)
        return 1

def update_ticket_counter():
    counter = read_ticket_counter()
    counter += 1
    with open("ticket_counter.json", "w") as file:
        json.dump({"ticket_counter": counter}, file)
    return counter

ticket_counter = 0
open_tickets = {}


class TicketView123(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="Create Ticket", style=discord.ButtonStyle.green, custom_id="create_ticket_button")
    async def create_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        global UserWhoCreatedTheTicketMFFFF
        UserWhoCreatedTheTicketMFFFF = interaction.user
        user_id = interaction.user.id
        if user_id in open_tickets:
            await interaction.response.send_message("You already have an open ticket.", ephemeral=True)
            return

        ticket_counter = update_ticket_counter()
        channel_name = f"ltc-{ticket_counter}"
        guild = interaction.guild
        category_name = "tickets"
        category = discord.utils.get(guild.categories, name=category_name)
        if not category:
            category = await guild.create_category(category_name)

        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(view_channel=True, read_messages=True, send_messages=True)
        }
        ticket_channel = await guild.create_text_channel(channel_name, overwrites=overwrites, category=category)
        open_tickets[user_id] = ticket_channel.id
        await interaction.response.send_message(f"Ticket channel {ticket_channel.mention} created!", ephemeral=True)

        await ticket_channel.send(f"{interaction.user.mention} please write the **UserId** of the other person.")

        while True:
            try:
                def check(m):
                    return m.author.id == user_id and m.channel.id == ticket_channel.id

                msg = await bot.wait_for('message', check=check, timeout=300)  
                other_user_id = int(msg.content)
                other_user = await guild.fetch_member(other_user_id)
                await ticket_channel.set_permissions(other_user, view_channel=True, read_messages=True, send_messages=True)
                await ticket_channel.send(f"{other_user.mention} has been added to the ticket.")
                await SendingAllDetails(ticket_channel)
                break  
            except ValueError:
                await ticket_channel.send("Invalid input. Please enter a valid numeric User ID.")
            except Exception as e:
                await ticket_channel.send("Failed to add the specified user to the ticket. Please try again.")



    
async def send_ltc(to_address, amount):
    try:
        global txid88
        txid88 = rpc_connection.sendtoaddress(to_address, amount)
        print(f"LTC SENT\nTransaction ID: {txid88}\n------------------------------")
    except JSONRPCException as e:
        print(f"An error occurred: {e}")




url = f'http://{rpc_user}:{rpc_password}@{rpc_host}:{rpc_port}/'
headers = {'content-type': 'application/json'}

processed_transactions = []
channel_states = {}
active_channels = set()

def rpc_request(payload):
    response = requests.post(url, headers=headers, data=json.dumps(payload))
    return response.json()

def get_new_address():
    payload = {"jsonrpc": "2.0", "method": "getnewaddress", "params": [], "id": 1}
    result = rpc_request(payload)
    return result['result']

def get_ltc_to_usd():
    url = "https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=USD"
    response = requests.get(url)
    data = response.json()
    return data['litecoin']['usd']



@tasks.loop(seconds=10)
async def check_transactions(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "listtransactions",
        "params": ["*", 10, 0, True],
        "id": 1
    }
    result = rpc_request(payload)
    for transaction in result['result']:
        if (transaction['address'] == address and
            transaction['category'] == 'receive' and
            transaction['txid'] not in processed_transactions):
            await print_transaction_details(transaction)
            processed_transactions.append(transaction['txid'])





@check_transactions.before_loop
async def before_check_transactions():
    await bot.wait_until_ready()






async def SendingAllDetails(channel):
    

    await channel.send(embed = discord.Embed(
        title="Thank you for choosing **RaiQuick** as your mm",
        color=discord.Color.from_rgb(0,0,220)
    ))
    await channel.send(embed = discord.Embed(
        title="Please read this text.",
        description=f"Please beware of **IMPERSONATERS**. Our Team will **NEVER** DM you to release the Ticket. If a Team Member is DMING you please ask for the reason. Also check UserId. [How to get UserId Video Tutorial](https://youtu.be/vskWZbNa7qo?si=H448VoJ5htfntrtl). Also beware of what the OTHER user is typing and telling you to do. If you have any Questions what these buttons do or why they exist. Please Ping a Staff Member and ask. We are here to help. Also be CAREFUL that the user who created the Ticket does not add another person. Please beware of that too. Our Staff Team is not responsible for that",
        color=discord.Color.from_rgb(0,0,220)
    ))
    
    await channel.send(embed = discord.Embed(
        title="Please choose Receiver or Sender",
        description=f"**Sender** \n- You are the one who is first **SENDING** the Litecoin to the Bot, after that the **Receiver** gets the LTC.\n"
                    f"**Receiver** \n- After the **BOT** confirms he got the LTC, you should give the **SENDER** the other stuff. After that he confirms he got and you get your LTC.\n"
                    f"**Why is only Sender there?** \n- The Sender has to press the Button first, after that the Receiver button appears. This was made because of a code problem.",
                    color=discord.Color.from_rgb(0,0,220)   
    ))
    await channel.send(embed=discord.Embed(
        title="Wrong Button clicked",
        description=f"If you missclicked just ping <@1168162359479644271> or any other Staff to close the Ticket. The other user has to confirm this too. After that we will close the ticket for you and you just gotta reopen one.\n"
                    f"\n"
                    f"**Some info**\n"
                    f"- When the first Button click does not work just try again. If it still doesnt work Ping a Staff/Support Member.\n\nIf a Supporter or higher tells you to send the LTC to them, then DONT. They might scam you. All staffs are trusted but its for your safety. If you do get scammed by an Staff or higher and him saying 'Ill hold LTC' or smth familiar, you wont get ur Funds back.",
        color=discord.Color.from_rgb(0,0,220)
    ), view=SenderButton())
    



global SenderVariable
SenderVariable = {}
global ReceiverVariable
ReceiverVariable = {}

class SenderButton(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="Sender", style=discord.ButtonStyle.blurple)
    async def SenderButton(self, interaction, button):
        if interaction.user.id in ReceiverVariable:
            await interaction.response.send_message("You are the receiver. You cant claim 2 roles.", ephemeral=True)
        elif interaction.user.id in SenderVariable:
            await interaction.response.send_message("You are a Sender in a different channel! Finish the other channel first and then come back here.", ephemeral =True)
        else:
            button.disabled =True
            channel = interaction.channel
            
            SenderVariable[interaction.user.id] = channel
            await interaction.response.edit_message(view=self)
            messagesender= await channel.send(f"{interaction.user.mention} Has claimed Sender")
            await channel.send(view=Receiverbutton())
            global SenderButAsinteractionUser
            SenderButAsinteractionUser = interaction.user
            
            

            global onDelete3
            async def onDelete3(interaction):
                await messagesender.delete()





class Receiverbutton(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="Receiver", style=discord.ButtonStyle.blurple)
    async def ReceiverButton(self, interaction, button):
        if interaction.user.id in SenderVariable:
            await interaction.response.send_message("You are the Sender. You cant claim 2 roles.", ephemeral=True)
        elif interaction.user.id in SenderVariable:
            await interaction.response.send_message("You are a receiver in a different channel! Finish the other channel first and then come back here.", ephemeral =True)
        else:
            button.disabled =True
            channel = interaction.channel
            ReceiverVariable[interaction.user.id] = channel
            await interaction.response.edit_message(view=self)
            messagereceiver = await channel.send(f"{interaction.user.mention} Has claimed Receiver")
            global ReceiverButAsinteractionUser
            ReceiverButAsinteractionUser = interaction.user
            await CallVerifyCation(interaction)

            global onDelete4
            async def onDelete4(interaction):
                await messagereceiver.delete()

async def CallVerifyCation(interaction):
    channel=interaction.channel
    sender = await channel.send(f"**SENDER** please write the amount in the modal. example: 10.73 ")
    message = await channel.send(embed=discord.Embed(
        title="Please state in the Modal the Amount of the Trade.",
        description=f"the **SENDER** has to write the amount of the Trade in the Modal.",
        color=discord.Color.from_rgb(0,0,230)
    ))
    await asyncio.sleep(0.8)
    modal = await channel.send(view=CallModalForVerifyCost())


class CallModalForVerifyCost(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="Amount of trade", style=discord.ButtonStyle.green)
    async def VerifyCostingForTrades(self, interaction, button):

        await interaction.response.send_modal(VerifyCostss())
        global EditCLoseButton
        async def EditCLoseButton(interaction):
            button.disabled=True
            await interaction.response.edit_message(view=self)



channel_trade_values = {}


class VerifyCostss(discord.ui.Modal, title="Verify cost of Ticket"):
    Price_Amount = discord.ui.TextInput(label="What is the amount of the Trade.", placeholder="Please write the amount here. If also has cents please type it in ',' (10,54) and not in '.'", required=True, max_length=10, style=discord.TextStyle.short)

    async def on_submit(self, interaction):
        if interaction.user.id in SenderVariable:
            input_value = self.Price_Amount.value.replace(",", ".")
            float_value = float(input_value)  
            float_value = float_value + 0.03
            formatted_amount = f"{float_value:.2f}"
            if float_value < 0.14:
                await interaction.response.send_message(f"please write a amount over 14 cents.")
            else:
                try:
                    channel_id = interaction.channel.id
                    channel_trade_values[channel_id] = float_value 

                    await EditCLoseButton(interaction)

                    await interaction.channel.send(f"Why is it 3 cents more? When LTC drops the Bot cant verify it since hes confirming it with $ amount and not LTC amount. Thats why. Just to be safe send 0.03$ more.")
                    await interaction.channel.send(embed=discord.Embed(
                        title="Amount of Trade",
                        description=f"Please confirm both of you that this trade is the value of **{formatted_amount} $**. First the Sender has to confirm it and then the receiver.",
                        color=discord.Color.from_rgb(0, 0, 255)
                    ))
                    await interaction.channel.send(view=VerifyCostSender())

                except ValueError:
                    
                    await interaction.response.send_message("Please enter a valid number value.", ephemeral=True)
        else:
           
            await interaction.response.send_message("You're not the sender.", ephemeral=True)




async def some_global_function(interaction):
    channel_id = interaction.channel.id
    if channel_id in channel_trade_values:
        trade_value = channel_trade_values[channel_id]
        await interaction.channel.send(f"The stored trade value is ${trade_value}")
    else:
        await interaction.channel.send("No trade value has been set for this channel.")



class VerifyCostSender(View):
    def __init__(self):
        super().__init__(timeout=None) 
    @discord.ui.button(label="Sender verify", style=discord.ButtonStyle.blurple)
    async def SenderIsVerifiingButton(self, interaction, button):
        channel=interaction.channel
        if interaction.user.id in SenderVariable:
            button.disabled = True
            await interaction.response.edit_message(view=self)
            await channel.send(f"{interaction.user.mention} confirmed.")
            await channel.send(view=VerifyCostReceiver())
        else:
            await interaction.response.send_message("youre not the sender.", ephemeral=True)

        


class VerifyCostReceiver(View):
    def __init__(self):
        super().__init__(timeout=None) 
    @discord.ui.button(label="Receiver verifiy", style=discord.ButtonStyle.blurple)
    async def ReceiverIsVerifiingButton(self, interaction, button):
        channel=interaction.channel
        if interaction.user.id in ReceiverVariable:
            button.disabled = True
            await interaction.response.edit_message(view=self)
            await channel.send(f"{interaction.user.mention} confirmed.")
            await StartOfSenderSendingMoneyToBotViaLTC(interaction)
        else:
            await interaction.response.send_message("youre not the receiver.", ephemeral=True)


async def StartOfSenderSendingMoneyToBotViaLTC(interaction):
    channel = interaction.channel
    channel_id = interaction.channel_id
    if channel_id in channel_states and channel_states[channel_id]['task'].is_running():
        await channel.send("Transaction monitoring is already running in this channel.")
        return
    
    if channel_id in channel_trade_values:
        trade_value = channel_trade_values[channel_id]
        
    
    new_address = get_new_address()
    ltc_amount = usd_to_ltc(trade_value)

    task = tasks.loop(seconds=10)(check_transactions_loop)
    task.start(new_address, interaction.channel, trade_value)

    processed_transactions = set()

    channel_states[channel_id] = {
        "address": new_address,
        "task": task,
        "ltc_amount": ltc_amount,
        "processed_transactions": processed_transactions
    }

   
    await channel.send(embed=discord.Embed(
        title="Sending LTC to Bot",
        description=f"For this deal to be continued the **SENDER** has to send now {trade_value}$ to the Bot\n\nLTC address: **`{new_address}`**\nUSD amount: **{trade_value}**\nLTC amount: **{ltc_amount:.8f}**\n"
                    f"\n**SOME INFO**\n"
                    f"When you use Exodus and you write the LTC amount, always check if the USD amount matched the USD amount here. If it does you can send it. If its more then change the USD amount to the actual deal amount. If its less do the same. If you sent the LTC tho and you saw the USD amount is more than the deal, then we see the amount you sent more as a TIP. Make sure not to send **MORE** or **LESS**.",
        color=discord.Color.from_rgb(0,0,198)
    ))
    await channel.send(f"{new_address}")
    await channel.send(f"{ltc_amount:.8f}")




async def check_transactions_loop(address, channel, amount_usd):
    await bot.wait_until_ready()
    channel_id = channel.id
    processed_transactions = channel_states[channel_id]['processed_transactions']
    
    while not bot.is_closed():
        result = rpc_request({
            "jsonrpc": "2.0",
            "method": "listtransactions",
            "params": ["*", 10, 0, True],
            "id": 1
        })
        transactions = result.get('result', [])
        for transaction in transactions:
            if transaction['address'] == address and transaction['category'] == 'receive' and transaction['txid'] not in processed_transactions:
                processed_transactions.add(transaction['txid'])
                await print_transaction_details(transaction, channel, amount_usd)
        await asyncio.sleep(30)


async def print_transaction_details(transaction, channel, amount_usd):
    await channel.send(embed=discord.Embed(
        title="Transaction Found!",
        description=f"A transaction has been found!\n\n"
                    f"**TXID**\n [**{transaction['txid']}**](https://live.blockcypher.com/ltc/tx/{transaction['txid']}/)\n\n"
                    f"**Waiting for confirmations (need 2/6)**",
        color=discord.Color.yellow()
    ))

    while True:

        updated_transaction = rpc_request({
            "jsonrpc": "2.0",
            "method": "gettransaction",
            "params": [transaction['txid']],
            "id": 1
        })['result']

        channel_id = channel.id
        if channel_id in channel_trade_values:
            trade_value = channel_trade_values[channel_id]

        if updated_transaction['confirmations'] > 1:
            

            try:
                usd_rate = get_ltc_to_usd()
                usd_amount = usd_rate * updated_transaction['amount']
                usd_amount = float(usd_amount)
                if float(f"{trade_value:.2f}") == float(f"{usd_amount:.2f}"):
                    rounded_number = usd_amount
                    
                else:
                    def round_up_to_nearest_cent(value):
                        return math.ceil(value * 100) / 100
                    
                    rounded_number = round_up_to_nearest_cent(usd_amount)
                    
            except ValueError:
                print("Please enter a valid number.")

            usd_rate = get_ltc_to_usd()
            usd_amount = usd_rate * updated_transaction['amount']
            usd_amount = float(usd_amount)

            if float(f"{amount_usd:.2f}") == float(f"{usd_amount:.2f}"):
                rounded_number = usd_amount
            else:
                rounded_number = math.ceil(usd_amount * 100) / 100

            if float(f"{amount_usd:.2f}") == float(f"{rounded_number:.2f}"):
                await channel.send(embed=discord.Embed(
                    title="Transaction Confirmed!",
                    description=f"Amount in LTC: **{updated_transaction['amount']}** LTC\n"
                                f"Amount in USD: **{usd_amount:.2f}$**\n"
                                f"Confirmations: **{updated_transaction['confirmations']}**\n"
                                f"TXID Link: **https://live.blockcypher.com/ltc/tx/{updated_transaction['txid']}/**",
                    color=discord.Color.from_rgb(0,255,0)
                ))

                
                await channel.send(f"<@&1234169966958215248>. The **SENDER** has to use the button under this text after you got the other side of the trade. After that press the Button so the LTC gets released.", view=IWJDIWJDIWJIDJWIDJIJ())
                break
            elif float(f"{amount_usd:.2f}") < float(f"{rounded_number:.2f}"):
                tip = float(f"{rounded_number:.2f}") - float(f"{amount_usd:.2f}")
                await channel.send(embed=discord.Embed(
                    title="Transaction Confirmed!",
                    description=f"Amount in LTC: **{updated_transaction['amount']}** LTC\n"
                                f"Amount in USD: **{amount_usd:.2f}$**\n"
                                f"Confirmations: **{updated_transaction['confirmations']}**\n"
                                f"TXID Link: **https://live.blockcypher.com/ltc/tx/{updated_transaction['txid']}/**\n\nWe got more {tip:.2f}$ than the actual deal. This will be seen as a Tip for us.",
                    color=discord.Color.from_rgb(0,255,0)
                ))

                
                
                await channel.send(f"<@&1234169966958215248>. The **SENDER** has to use the button under this text after you got the other side of the trade. After that press the Button so the LTC gets released.", view=IWJDIWJDIWJIDJWIDJIJ())
                break
            else:
                missing_number = float(amount_usd) - float(f"{usd_amount:.2f}")
                await channel.send(f"We didn't receive the full amount of ${amount_usd}. There's still ${missing_number}$ left. Please contact raichi so he can give back the LTC. ")
        else:
            await asyncio.sleep(15)  


check_transactions.before_loop(before_check_transactions)

ConfirmNumberCHECKKK = 0




class IWJDIWJDIWJIDJWIDJIJ(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="confirm", style=discord.ButtonStyle.blurple)
    async def oiuzgjjfghjg(self, interaction, button):
        channel = interaction.channel
        if interaction.user.id in SenderVariable:
            
            button.disabled = True

                
            await interaction.response.edit_message(view=self)
            await channel.send("Please click on the button below as your last confirm.")
            await channel.send(view=VerifyButtonBeforeSendingLTCYA())

        else:
            await interaction.response.send_message("Your not the sender", ephemeral=True)


class VerifyButtonBeforeSendingLTCYA(View):
    def __init__(self):
        super().__init__(timeout=None) 

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.blurple)
    async def aisjdiwjdaijsdj(self, interaction, button):
        if interaction.user.id in SenderVariable:
            channel = interaction.channel
            button.disabled = True
            await interaction.response.edit_message(view=self)
            
            await channel.send(f"**RECEIVER** please write your LTC address in the modal under this text.")
            await channel.send(view=buttonforModalaisjdoajwdijaisj())
            
        else:
            await interaction.response.send_message("you are not the sender", ephemeral=True)
        
class buttonforModalaisjdoajwdijaisj(View):
    def __init__(self):
        super().__init__(timeout=None) 
    @discord.ui.button(label="Your LTC addy here", style=discord.ButtonStyle.blurple)
    async def poiuztrewefghjko(self, interaction, button):
        channel = interaction.channel
        await interaction.response.send_modal(ModalToGetReceiverAddy())

        global EditCLoseButton2
        async def EditCLoseButton2(interaction):
            button.disabled=True
            await interaction.response.edit_message(view=self)



class ModalToGetReceiverAddy(discord.ui.Modal, title="LTC address receiver"):

    
    addy = discord.ui.TextInput(label="LTC address here", placeholder="Here you write your LTC address. You also need to confirm it before we send the LTC.", required=True, max_length=99, style=discord.TextStyle.short)

    async def on_submit(self, interaction: discord.Interaction):
        if interaction.user.id in ReceiverVariable:
            
            global ltc_addy123
            ltc_addy123 = self.addy.value
            await EditCLoseButton2(interaction)

            channel = interaction.channel
            await channel.send(f"Are you sure that `{ltc_addy123}` is your Litecoin address? Click on the Button to confirm it.")
            await channel.send(view=LastTimeVerifying())
        else:
            await interaction.response.send_message("You are not the receiver", ephemeral=True)



class LastTimeVerifying(View):
    def __init__(self):
        super().__init__(timeout=None) 
    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.blurple)
    async def confirm_button(self, interaction: discord.Interaction, button: Button):
        global usd_amount  
        channel = interaction.channel
        
        if interaction.user.id in ReceiverVariable:
            try:
                channel_id = interaction.channel_id
                if channel_id in channel_trade_values:
                    trade_value = channel_trade_values[channel_id]

                trade_value = float(trade_value)
                real_trade_value = trade_value
                
                file_path = 'LitecoinCore/MMPassFile.json'
    
                button.disabled=True
                await interaction.response.edit_message(view=self)
                try:
                    with open(file_path, 'r') as file:
                        data = json.load(file)
                except FileNotFoundError:
                    data = {'MM pass': {}}
                
                user_id = str(interaction.user.id)
                
                win_count = data['MM pass'].get(user_id, 0)
                
                if trade_value > 50:
                    if win_count > 0:

                        await channel.send(embed=discord.Embed(
                            title="Wanna use MM Pass?",
                            description=f"We saw that you have a MM pass. Do you want to use it for this trade?",
                            color=discord.Color.from_rgb(0,0,255)
                        ))
                        await channel.send(view=YesOrNoButtonMMPass())
                        

                    else:
                        
                        button.disabled=True
                        await interaction.response.edit_message(view=self)
                        
                        trade_value = trade_value * 0.995
                        trade_value = trade_value - 0.02

                        def usd_to_ltc(trade_value):
                            ltc_price = get_ltc_to_usd()
                            return trade_value / ltc_price

                        ltc_amount = usd_to_ltc(trade_value)


                        await send_ltc(ltc_addy123, f"{ltc_amount:.8f}")
                        await channel.send(embed=discord.Embed(
                            title="LTC sent",
                            description=f"Successfully sent **{trade_value:.2f}$** to **`{ltc_addy123}`**\n\n **TXID**\n [**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)\n\n Incase you're wondering, there is always a 2 cent fee to prevent the Bot of sending more money. Also if the deal is above 50$ theres a 0.5% fee.",
                            color= discord.Color.from_rgb(0,255,0)
                        ))

                        try:
                            file_path = 'LitecoinCore/TransactionData.json'

                            with open(file_path, 'r') as file:
                                data = json.load(file)

                            new_transaction = {'TXID': txid88, 'usd_amount': f"{real_trade_value:.2f}","ltc_amount": f"{ltc_amount:.8f}", "sender": f"{SenderButAsinteractionUser.name}, {SenderButAsinteractionUser.id}", "receiver": f"{ReceiverButAsinteractionUser.name}, {ReceiverButAsinteractionUser.id}"}  
                            data['Transactions'].append(new_transaction)  

                            with open(file_path, 'w') as file:
                                json.dump(data, file, indent=4)
                        except Exception as e:
                            print("Error", e)

                        try:
                                
                            try:
                                file_path = 'LitecoinCore/StatsFile.json'

                                try:
                                    with open(file_path, 'r') as file:
                                        data = json.load(file)
                                except FileNotFoundError:
                                    data = {'Stats': {}}

                                
                                real_trade_value = float(real_trade_value)  

                                print(f"Trade value to add: {real_trade_value}")

                                user_id = str(ReceiverButAsinteractionUser.id)
                                previous_value = data['Stats'].get(user_id, 0.0)
                                new_value = float(previous_value) + real_trade_value
                                data['Stats'][user_id] = new_value

                                print(f"Updated {user_id} from {previous_value} to {new_value}")

                                user_id2 = str(SenderButAsinteractionUser.id)
                                previous_value2 = data['Stats'].get(user_id2, 0.0)
                                new_value2 = float(previous_value2) + real_trade_value
                                data['Stats'][user_id2] = new_value2

                                print(f"Updated {user_id2} from {previous_value2} to {new_value2}")

                                with open(file_path, 'w') as file:
                                    json.dump(data, file, indent=4)

                            except Exception as e:
                                print("Error", e)

                        except Exception as e:
                            print("Error", e)

                        try:
                            try:
                                file_path = 'LitecoinCore/StatsFile2.json'

                                try:
                                    with open(file_path, 'r') as file:
                                        data = json.load(file)
                                    print("File loaded successfully.")
                                except FileNotFoundError:
                                    data = {'Stats': {}}
                                    print("File not found. Created a new data structure.")

                                user_id = str(ReceiverButAsinteractionUser.id)
                                print(f"Updating stats for Receiver ID: {user_id}")

                                if user_id in data['Stats']:
                                    data['Stats'][user_id] += 1
                                else:
                                    data['Stats'][user_id] = 1

                                
                                user_id2 = str(SenderButAsinteractionUser.id)
                                print(f"Updating stats for Sender ID: {user_id2}")

                                if user_id2 in data['Stats']:
                                    data['Stats'][user_id2] += 1
                                else:
                                    data['Stats'][user_id2] = 1

                                
                                try:
                                    with open(file_path, 'w') as file:
                                        json.dump(data, file, indent=4)
                                    print("Data written to file successfully.")
                                except Exception as e:
                                    print(f"Failed to write data to file: {e}")
                            except Exception as e:
                                print("Error", e)

                        except Exception as e:
                            print("Error", e)

                        del SenderVariable[SenderButAsinteractionUser.id]
                        del ReceiverVariable[ReceiverButAsinteractionUser.id]

                        

                        embed=discord.Embed(
                        title="Auto vouch",
                        description=f"This Ticket is now market done. An automatic message will be sent to <#1234199692783390762>. The sender and receiver will be anonymous. What there will be is the TXID and the amount of trade (in USD and LTC)\n\n",
                                    color = discord.Color.from_rgb(0,255,0)
                        )
                        embed.add_field(name="Sender", value="`anonymous`", inline=True)
                        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
                        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
                        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
                        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)
                        embed.add_field(name="THIS IS ONLY ON HOW THE VOUCH FORMAT LOOKS LIKE.", value=f"ONLY TEST FORMAT!!!", inline=False)
                        await channel.send(embed=embed)
                        await channel.send(f"<@&1234169966958215248> can you please both go to <#1237118568445771816> and vouch <@1229800684766101524>.")

                        

                        embed=discord.Embed(
                            title="Auto vouch",
                            description=f"A new auto vouch has appeared\n\n",
                            color = discord.Color.from_rgb(0,255,0)
                                        
                        )
                        embed.add_field(name="Sender", value="`anonymous`", inline=True)
                        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
                        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
                        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
                        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)

                        channel2 = client.get_channel(1234199692783390762)
                        await channel2.send(embed=embed)



                        del open_tickets[UserWhoCreatedTheTicketMFFFF.id]

                        await OnDeleteChannelWhenDone(channel)
                
                else:
                    
                    

                    trade_value = trade_value - 0.02

                    def usd_to_ltc(trade_value):
                        ltc_price = get_ltc_to_usd()
                        return trade_value / ltc_price

                    ltc_amount = usd_to_ltc(trade_value)


                    await send_ltc(ltc_addy123, f"{ltc_amount:.8f}")
                    await channel.send(embed=discord.Embed(
                        title="LTC sent",
                        description=f"Successfully sent **{trade_value:.2f}$** to **`{ltc_addy123}`**\n\n **TXID**\n [**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)\n\n Incase you're wondering, there is always a 2 cent fee to prevent the Bot of sending more money. Also if the deal is above 50$ theres a 0.5% fee.",
                        color= discord.Color.from_rgb(0,255,0)
                    ))

                    try:
                        file_path = 'LitecoinCore/TransactionData.json'

                        with open(file_path, 'r') as file:
                            data = json.load(file)

                        new_transaction = {'TXID': txid88, 'usd_amount': f"{real_trade_value:.2f}","ltc_amount": f"{ltc_amount:.8f}", "sender": f"{SenderButAsinteractionUser.name}, {SenderButAsinteractionUser.id}", "receiver": f"{ReceiverButAsinteractionUser.name}, {ReceiverButAsinteractionUser.id}"}  
                        data['Transactions'].append(new_transaction)  

                        with open(file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                    except Exception as e:
                        print("Error", e)

                    try:
                            
                        try:
                            file_path = 'LitecoinCore/StatsFile.json'

                            try:
                                with open(file_path, 'r') as file:
                                    data = json.load(file)
                            except FileNotFoundError:
                                data = {'Stats': {}}

                            
                            real_trade_value = float(real_trade_value)  

                            print(f"Trade value to add: {real_trade_value}")

                            user_id = str(ReceiverButAsinteractionUser.id)
                            previous_value = data['Stats'].get(user_id, 0.0)
                            new_value = float(previous_value) + real_trade_value
                            data['Stats'][user_id] = new_value

                            print(f"Updated {user_id} from {previous_value} to {new_value:.2f}")

                            user_id2 = str(SenderButAsinteractionUser.id)
                            previous_value2 = data['Stats'].get(user_id2, 0.0)
                            new_value2 = float(previous_value2) + real_trade_value
                            data['Stats'][user_id2] = new_value2

                            print(f"Updated {user_id2} from {previous_value2} to {new_value2:.2f}")

                            with open(file_path, 'w') as file:
                                json.dump(data, file, indent=4)

                            # ------------------------

                            file_path = 'LitecoinCore/StatsFile2.json'

                            try:
                                with open(file_path, 'r') as file:
                                    data = json.load(file)
                                print("File loaded successfully.")
                            except FileNotFoundError:
                                data = {'Stats': {}}
                                print("File not found. Created a new data structure.")

                            user_id = str(ReceiverButAsinteractionUser.id)
                            print(f"Updating stats for Receiver ID: {user_id}")

                            if user_id in data['Stats']:
                                data['Stats'][user_id] += 1
                            else:
                                data['Stats'][user_id] = 1

                            
                            user_id2 = str(SenderButAsinteractionUser.id)
                            print(f"Updating stats for Sender ID: {user_id2}")

                            if user_id2 in data['Stats']:
                                data['Stats'][user_id2] += 1
                            else:
                                data['Stats'][user_id2] = 1

                            
                            try:
                                with open(file_path, 'w') as file:
                                    json.dump(data, file, indent=4)
                                print("Data written to file successfully.")
                            except Exception as e:
                                print(f"Failed to write data to file: {e}")

                        except Exception as e:
                            print("Error", e)

                            

                    except Exception as e:
                        print("Error", e)


                    del SenderVariable[SenderButAsinteractionUser.id]
                    del ReceiverVariable[ReceiverButAsinteractionUser.id]

                    

                    embed=discord.Embed(
                    title="Auto vouch",
                    description=f"This Ticket is now market done. An automatic message will be sent to <#1234199692783390762>. The sender and receiver will be anonymous. What there will be is the TXID and the amount of trade (in USD and LTC)\n\n",
                                color = discord.Color.from_rgb(0,255,0)
                    )
                    embed.add_field(name="Sender", value="`anonymous`", inline=True)
                    embed.add_field(name="Receiver", value="`anonymous`", inline=True)
                    embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
                    embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
                    embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)
                    embed.add_field(name="THIS IS ONLY ON HOW THE VOUCH FORMAT LOOKS LIKE.", value=f"ONLY TEST FORMAT!!!", inline=False)
                    await channel.send(embed=embed)
                    await channel.send(f"<@&1234169966958215248> can you please both go to <#1237118568445771816> and vouch <@1229800684766101524>.")
                    

                    embed=discord.Embed(
                        title="Auto vouch",
                        description=f"A new auto vouch has appeared\n\n",
                        color = discord.Color.from_rgb(0,255,0)
                                    
                    )
                    embed.add_field(name="Sender", value="`anonymous`", inline=True)
                    embed.add_field(name="Receiver", value="`anonymous`", inline=True)
                    embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
                    embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
                    embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)

                    channel2 = client.get_channel(1234199692783390762)
                    await channel2.send(embed=embed)



                    del open_tickets[UserWhoCreatedTheTicketMFFFF.id]

                    await OnDeleteChannelWhenDone(channel)


                
            except Exception as e:
                await interaction.response.send_message(f"Oh no. There was a error. Better pinging the mods \n\n Error: {e}")
        else:
            await interaction.response.send_message("You are not the receiver", ephemeral=True)







class YesOrNoButtonMMPass(View):
    def __init__(self):
        super().__init__(timeout=None) 

    async def disable_buttons(self, interaction):
        for item in self.children:
            if isinstance(item, discord.ui.Button):
                item.disabled = True
        await interaction.response.edit_message(view=self)


    @discord.ui.button(label="Yes", style=discord.ButtonStyle.green)
    async def OnYesPressing(self, interaction: discord.Interaction, button):
       
        file_path = 'LitecoinCore/MMPassFile.json'
        channel = interaction.channel
        channel_id = interaction.channel_id
        if channel_id in channel_trade_values:
            trade_value = channel_trade_values[channel_id]

        trade_value = float(trade_value)
        real_trade_value = trade_value
    
    
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
        except FileNotFoundError:
            data = {'MM pass': {}}
        
        user_id = str(interaction.user.id)
        
        win_count = data['MM pass'].get(user_id, 0)
        data['MM pass'][user_id] -= 1
        await channel.send(f"Alright. We will use one of your MM Passes for this Trade. You now have {win_count} MM passes.")
        
        await self.disable_buttons(interaction)

        trade_value = trade_value - 0.02

        def usd_to_ltc(trade_value):
            ltc_price = get_ltc_to_usd()
            return trade_value / ltc_price

        ltc_amount = usd_to_ltc(trade_value)


        await send_ltc(ltc_addy123, f"{ltc_amount:.8f}")
        await channel.send(embed=discord.Embed(
            title="LTC sent",
            description=f"Successfully sent **{trade_value:.2f}$** to **`{ltc_addy123}`**\n\n **TXID**\n [**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)\n\n Incase you're wondering, there is always a 2 cent fee to prevent the Bot of sending more money. Also if the deal is above 50$ theres a 0.5% fee.",            color= discord.Color.from_rgb(0,255,0)
        ))

        try:
            file_path = 'LitecoinCore/TransactionData.json'

            with open(file_path, 'r') as file:
                data = json.load(file)

            new_transaction = {'TXID': txid88, 'usd_amount': f"{real_trade_value:.2f}","ltc_amount": f"{ltc_amount:.8f}", "sender": f"{SenderButAsinteractionUser.name}, {SenderButAsinteractionUser.id}", "receiver": f"{ReceiverButAsinteractionUser.name}, {ReceiverButAsinteractionUser.id}"}  
            data['Transactions'].append(new_transaction)  

            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)
        except Exception as e:
            print("Error", e)

        try:
                            
            try:
                file_path = 'LitecoinCore/StatsFile.json'

                try:
                    with open(file_path, 'r') as file:
                        data = json.load(file)
                except FileNotFoundError:
                    data = {'Stats': {}}

                
                real_trade_value = float(real_trade_value)  

                print(f"Trade value to add: {real_trade_value}")

                user_id = str(ReceiverButAsinteractionUser.id)
                previous_value = data['Stats'].get(user_id, 0.0)
                new_value = float(previous_value) + real_trade_value
                data['Stats'][user_id] = new_value

                print(f"Updated {user_id} from {previous_value} to {new_value}")

                user_id2 = str(SenderButAsinteractionUser.id)
                previous_value2 = data['Stats'].get(user_id2, 0.0)
                new_value2 = float(previous_value2) + real_trade_value
                data['Stats'][user_id2] = new_value2

                print(f"Updated {user_id2} from {previous_value2} to {new_value2}")

                with open(file_path, 'w') as file:
                    json.dump(data, file, indent=4)

            except Exception as e:
                print("Error", e)

        except Exception as e:
            print("Error", e)

        try:
            try:
                file_path = 'LitecoinCore/StatsFile2.json'

                try:
                    with open(file_path, 'r') as file:
                        data = json.load(file)
                    print("File loaded successfully.")
                except FileNotFoundError:
                    data = {'Stats': {}}
                    print("File not found. Created a new data structure.")

                user_id = str(ReceiverButAsinteractionUser.id)
                print(f"Updating stats for Receiver ID: {user_id}")

                if user_id in data['Stats']:
                    data['Stats'][user_id] += 1
                else:
                    data['Stats'][user_id] = 1

                
                user_id2 = str(SenderButAsinteractionUser.id)
                print(f"Updating stats for Sender ID: {user_id2}")

                if user_id2 in data['Stats']:
                    data['Stats'][user_id2] += 1
                else:
                    data['Stats'][user_id2] = 1

                
                try:
                    with open(file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    print("Data written to file successfully.")
                except Exception as e:
                    print(f"Failed to write data to file: {e}")
            except Exception as e:
                print("Error", e)

        except Exception as e:
            print("Error", e)

        del SenderVariable[SenderButAsinteractionUser.id]
        del ReceiverVariable[ReceiverButAsinteractionUser.id]


        embed=discord.Embed(
            title="Auto vouch",
            description=f"This Ticket is now market done. An automatic message will be sent to <#1234199692783390762>. The sender and receiver will be anonymous. What there will be is the TXID and the amount of trade (in USD and LTC)\n\n",
                        color = discord.Color.from_rgb(0,255,0)
        )
        embed.add_field(name="Sender", value="`anonymous`", inline=True)
        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)
        embed.add_field(name="THIS IS ONLY ON HOW THE VOUCH FORMAT LOOKS LIKE.", value=f"ONLY TEST FORMAT!!!", inline=False)
        await channel.send(embed=embed)
        await channel.send(f"<@&1234169966958215248> can you please both go to <#1237118568445771816> and vouch <@1229800684766101524>.")
        

        embed=discord.Embed(
            title="Auto vouch",
            description=f"A new auto vouch has appeared\n\n",
            color = discord.Color.from_rgb(0,255,0)
                        
        )
        embed.add_field(name="Sender", value="`anonymous`", inline=True)
        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)

        channel2 = client.get_channel(1234199692783390762)
        await channel2.send(embed=embed)



        del open_tickets[UserWhoCreatedTheTicketMFFFF.id]

        await OnDeleteChannelWhenDone(channel)



    @discord.ui.button(label="No", style=discord.ButtonStyle.red)
    async def OnNoPressing(self, interaction: discord.Interaction, button):
        

        channel_id = interaction.channel_id
        if channel_id in channel_trade_values:
            trade_value = channel_trade_values[channel_id]

        trade_value = float(trade_value)
        real_trade_value = trade_value
        if trade_value > 50:
            trade_value = trade_value * 0.995
            print(trade_value)
        

        channel = interaction.channel
                    
        await self.disable_buttons(interaction)

        trade_value = trade_value - 0.02
        print(trade_value)
        def usd_to_ltc(trade_value):
            ltc_price = get_ltc_to_usd()
            return trade_value / ltc_price

        ltc_amount = usd_to_ltc(trade_value)


        await send_ltc(ltc_addy123, f"{ltc_amount:.8f}")
        await channel.send(embed=discord.Embed(
            title="LTC sent",
            description=f"Successfully sent **{trade_value:.2f}$** to **`{ltc_addy123}`**\n\n **TXID**\n [**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)\n\n Incase you're wondering, there is always a 2 cent fee to prevent the Bot of sending more money. Also if the deal is above 50$ theres a 0.5% fee.",
            color= discord.Color.from_rgb(0,255,0)
        ))

        try:
            file_path = 'LitecoinCore/TransactionData.json'

            with open(file_path, 'r') as file:
                data = json.load(file)

            new_transaction = {'TXID': txid88, 'usd_amount': f"{real_trade_value:.2f}","ltc_amount": f"{ltc_amount:.8f}", "sender": f"{SenderButAsinteractionUser.name}, {SenderButAsinteractionUser.id}", "receiver": f"{ReceiverButAsinteractionUser.name}, {ReceiverButAsinteractionUser.id}"}  
            data['Transactions'].append(new_transaction)  

            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)
        except Exception as e:
            print("Error", e)

        try:
                            
            try:
                file_path = 'LitecoinCore/StatsFile.json'

                try:
                    with open(file_path, 'r') as file:
                        data = json.load(file)
                except FileNotFoundError:
                    data = {'Stats': {}}

                
                real_trade_value = float(real_trade_value)  

                print(f"Trade value to add: {real_trade_value}")

                user_id = str(ReceiverButAsinteractionUser.id)
                previous_value = data['Stats'].get(user_id, 0.0)
                new_value = float(previous_value) + real_trade_value
                data['Stats'][user_id] = new_value

                print(f"Updated {user_id} from {previous_value} to {new_value}")

                user_id2 = str(SenderButAsinteractionUser.id)
                previous_value2 = data['Stats'].get(user_id2, 0.0)
                new_value2 = float(previous_value2) + real_trade_value
                data['Stats'][user_id2] = new_value2

                print(f"Updated {user_id2} from {previous_value2} to {new_value2}")

                with open(file_path, 'w') as file:
                    json.dump(data, file, indent=4)

            except Exception as e:
                print("Error", e)

        except Exception as e:
            print("Error", e)

        try:
            try:
                file_path = 'LitecoinCore/StatsFile2.json'

                try:
                    with open(file_path, 'r') as file:
                        data = json.load(file)
                    print("File loaded successfully.")
                except FileNotFoundError:
                    data = {'Stats': {}}
                    print("File not found. Created a new data structure.")

                user_id = str(ReceiverButAsinteractionUser.id)
                print(f"Updating stats for Receiver ID: {user_id}")

                if user_id in data['Stats']:
                    data['Stats'][user_id] += 1
                else:
                    data['Stats'][user_id] = 1

                
                user_id2 = str(SenderButAsinteractionUser.id)
                print(f"Updating stats for Sender ID: {user_id2}")

                if user_id2 in data['Stats']:
                    data['Stats'][user_id2] += 1
                else:
                    data['Stats'][user_id2] = 1

                
                try:
                    with open(file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    print("Data written to file successfully.")
                except Exception as e:
                    print(f"Failed to write data to file: {e}")
            except Exception as e:
                print("Error", e)

        except Exception as e:
            print("Error", e)

        del SenderVariable[SenderButAsinteractionUser.id]
        del ReceiverVariable[ReceiverButAsinteractionUser.id]

        embed=discord.Embed(
            title="Auto vouch",
            description=f"This Ticket is now market done. An automatic message will be sent to <#1234199692783390762>. The sender and receiver will be anonymous. What there will be is the TXID and the amount of trade (in USD and LTC)\n\n",
            color = discord.Color.from_rgb(0,255,0)
        )
        embed.add_field(name="Sender", value="`anonymous`", inline=True)
        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)
        embed.add_field(name="THIS IS ONLY ON HOW THE VOUCH FORMAT LOOKS LIKE.", value=f"ONLY TEST FORMAT!!!", inline=False)
        await channel.send(embed=embed)
        await channel.send(f"<@&1234169966958215248> can you please both go to <#1237118568445771816> and vouch <@1229800684766101524>.")
        

        embed=discord.Embed(
            title="Auto vouch",
            description=f"A new auto vouch has appeared\n\n",
            color = discord.Color.from_rgb(0,255,0)
                        
        )
        embed.add_field(name="Sender", value="`anonymous`", inline=True)
        embed.add_field(name="Receiver", value="`anonymous`", inline=True)
        embed.add_field(name="**TXID**", value=f"\n[**{txid88}**](https://live.blockcypher.com/ltc/tx/{txid88}/)", inline=False)
        embed.add_field(name="USD amount", value=f"{trade_value:.2f}", inline=True)
        embed.add_field(name="LTC amount", value=f"{ltc_amount:.8f}", inline=True)

        channel2 = client.get_channel(1234199692783390762)
        await channel2.send(embed=embed)

        

        del open_tickets[UserWhoCreatedTheTicketMFFFF.id]

        await OnDeleteChannelWhenDone(channel)



def usd_to_ltc(usd_amount):
    usd_rate = get_ltc_to_usd()
    return float(usd_amount) / usd_rate
    

game_database_path = 'LitecoinCore/game_database.json'
mm_pass_file_path = 'LitecoinCore/MMPassFile.json'

def load_game_database():
    try:
        with open(game_database_path, 'r') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}

def save_game_database(game_database):
    with open(game_database_path, 'w') as file:
        json.dump(game_database, file, indent=4)

game_database = load_game_database()

class MinesGame(discord.ui.View):
    def __init__(self, winning_button, user):
        super().__init__(timeout=None)
        self.winning_button = winning_button
        self.user = user
        self.attempts = 0

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user == self.user

    async def button_click(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.attempts += 1
        button.disabled = True
        if button.custom_id == self.winning_button:
            button.label = 'Win!'
            button.style = discord.ButtonStyle.green
            end_message = "Congratulations! You won 1 free MM pass"
            await self.update_mm_pass(interaction)
        else:
            button.label = 'Mine'
            button.style = discord.ButtonStyle.red
            end_message = "Game over. The winning button was marked 'Win!'. Wait about 1 hour to play again."

        for btn in self.children:
            btn.disabled = True
            if btn.custom_id == self.winning_button and btn.label != 'Win!':
                btn.label = 'Win!'
                btn.style = discord.ButtonStyle.green

        await interaction.response.edit_message(view=self, content=end_message)
        await self.register_game_end(interaction.user.id)

    async def register_game_end(self, user_id):
        game_database[str(user_id)] = datetime.now().isoformat()
        save_game_database(game_database)
        asyncio.create_task(self.remove_user_after_delay(str(user_id), 3600)) 

    async def remove_user_after_delay(self, user_id, delay):
        await asyncio.sleep(delay)
        if user_id in game_database:
            del game_database[user_id]
            save_game_database(game_database)

    async def update_mm_pass(self, interaction):
        try:
            with open(mm_pass_file_path, 'r') as file:
                data = json.load(file)
        except FileNotFoundError:
            data = {'MM pass': {}}

        user_id = str(interaction.user.id)
        if user_id in data['MM pass']:
            data['MM pass'][user_id] += 1
        else:
            data['MM pass'][user_id] = 1

        with open(mm_pass_file_path, 'w') as file:
            json.dump(data, file, indent=4)


@client.tree.command(name='mines', description='Start a mines game')
async def mines(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    if user_id in game_database:
        user_time = datetime.fromisoformat(game_database[user_id])
        if datetime.now() - user_time < timedelta(hours=1):
            remaining_time = (timedelta(hours=1) - (datetime.now() - user_time)).total_seconds()
            await interaction.response.send_message(f"You must wait {remaining_time // 60:.0f} minutes before playing again.", ephemeral=True)
            return

    winning_button = f'button_{random.randint(1, 25)}'
    view = MinesGame(winning_button, interaction.user)
    for i in range(25):
        button_id = f'button_{i+1}'
        row = i // 5
        button = discord.ui.Button(label='?', style=discord.ButtonStyle.grey, custom_id=button_id, row=row)
        button.callback = lambda inter, b=button: view.button_click(inter, b)
        view.add_item(button)
    await interaction.response.send_message('You have **1** try to win a free MM pass. Good luck!', view=view)

    def reschedule_cleanup_tasks():
        for user_id, timestamp in game_database.items():
            user_time = datetime.fromisoformat(timestamp)
            delay = (datetime.now() - user_time).total_seconds()
            if delay < 3600:
                asyncio.create_task(MinesGame(None, None).remove_user_after_delay(user_id, 3600 - delay))

    reschedule_cleanup_tasks()





@client.tree.command(name="stats", description="Get the stats from a user")
@app_commands.describe(user="The user to fetch stats for (optional)")
async def stats(interaction: discord.Interaction, user: discord.Member = None):
    if user is None:
        user = interaction.user  

    file_path = "LitecoinCore/StatsFile.json"
    file_path2 = "LitecoinCore/StatsFile2.json"

    try:
        with open(file_path, 'r') as file:
            data = json.load(file)
    except FileNotFoundError:
        data = {'Stats': {}}

    try:
        with open(file_path2, 'r') as file:
            data2 = json.load(file)
    except FileNotFoundError:
        data2 = {'Stats': {}}

    user_stats = data['Stats'].get(str(user.id), 0)
    user_stats2 = data2['Stats'].get(str(user.id), 0)

   
    embed = discord.Embed(
        title=f"{user.name}",
        color=discord.Color.from_rgb(0,255,0)
    )
    
    embed.add_field(name="Total USD Value", value=f"${user_stats:.2f}", inline=True)
    embed.add_field(name="Deals Completed", value=str(user_stats2), inline=True)
    embed.set_thumbnail(url=user.display_avatar.url)


    await interaction.response.send_message(embed=embed)


async def remove_all_members_from_role(guild):
    role_name = "Blocked from Mines"
    role = discord.utils.get(guild.roles, name=role_name)
    if role:
        for member in role.members:
            try:
                await member.remove_roles(role)
            except discord.Forbidden:
                print(f"I do not have permission to remove roles from {member.display_name} in {guild.name}.")
            except Exception as e:
                print(f"An error occurred in {guild.name}: {str(e)}")


@tasks.loop(minutes=10)
async def update_member_count():
    guild = bot.get_guild(1234166898413797478)
    if guild is None:
        print("Guild not found!")
        return

    channel = bot.get_channel(1235274294565802006)
    if channel is None:
        print("Channel not found!")
        return

    member_count = sum(1 for member in guild.members if not member.bot)
    new_name = f"Members: {member_count}"
    
    await channel.edit(name=new_name)

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return
    raise error


@client.tree.command(name="add_mm_passes", description=f"Adds to someone MM passes")
@app_commands.describe(user="Who should the MM passes be added to?", number="How many MM passes?")
async def oakowjdiuuhioiuztzhujijiuztzuhijij(interaction: discord.Interaction, user: discord.Member, number: int):
    if interaction.user.id == 1168162359479644271:
        file_path = 'LitecoinCore/MMPassFile.json'
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
        except FileNotFoundError:
            data = {'MM pass': {}}

        user_id = str(user.id)
        if user_id in data['MM pass']:
            data['MM pass'][user_id] += number
        else:
            data['MM pass'][user_id] = number

        with open(file_path, 'w') as file:
            json.dump(data, file, indent=4)

        await interaction.response.send_message(f"Added {number} mm pass/passes to {user.mention}")
    else:
        await interaction.response.send_message("Youre not raichi lol")

async def OnDeleteChannelWhenDone(channel):
    try:
        await asyncio.sleep(300)
        await channel.send("deleting channel!")
        await asyncio.sleep(3)
        await channel.delete()
    except Exception as e:
        print("Error while deleting a Ticket automatically:", e)


@client.tree.command(name="ping", description="The ping for bot")
async def OnPingCommand(interaction):
    await interaction.response.send_message(f"Pong! {round(bot.latency * 1000)}ms")


@bot.event
async def on_member_join(member):
    guild = member.guild
    role_name = "Member"  

    role = discord.utils.get(guild.roles, name=role_name)
    if role:
        try:
            await member.add_roles(role)
            
        except discord.Forbidden:
            print(f"Do not have permission to assign roles in {guild.name}")
        except discord.HTTPException as e:
            print(f"Failed to assign role due to an HTTP error: {e}")
    else:
        print(f"Role '{role_name}' not found in {guild.name}.")



authorized_users = {1168162359479644271, 1201008639599706132, 603709678765211659, 1011946213463052429, 1231971121411264596, 564071366890881025, 1166018547219185767}  

@client.tree.command(name="close", description="Closes a Ticket.")
async def ClosingATicketFRFR(interaction):
    if interaction.user.id in authorized_users:
        channel = interaction.channel
        if isinstance(channel, discord.TextChannel) and channel.name.startswith("ltc-"):
            try:
                await interaction.response.send_message("Deleting")
                await asyncio.sleep(0.5)
                await channel.delete()
                if UserWhoCreatedTheTicketMFFFF in open_tickets:
                    del open_tickets[UserWhoCreatedTheTicketMFFFF.id]
                else:
                    print(f"Deleted ticket: ", channel.name)
            except Exception as e:
                await interaction.response.send_message(f"Error: {e}")
        else:
            await interaction.response.send_message("This command can only be used in a 'ltc-' channel.", ephemeral=True)
    else:
        await interaction.response.send_message(f"If your a staff ping me in <#1234168574533304330>. Otherwise you cant use the command.", ephemeral=True)





def load_mm_passes2():
    with open('LitecoinCore/MMPassFile.json', 'r') as file:
        data = json.load(file)
    return data['MM pass']

@bot.tree.command(name="mm_pass", description="See how many MM Passes you got.")
async def mm_pass(interaction: discord.Interaction):
    user_id = str(interaction.user.id) 
    mm_passes = load_mm_passes2()

    pass_count = mm_passes.get(user_id, 0)

    if pass_count == 0:
        response = "You do not have any MM Passes."
    else:
        response = f"You have {pass_count} MM Pass{'es' if pass_count > 1 else ''}."

    await interaction.response.send_message(response, ephemeral=True)


thresholds = {
    0.01: '1235184731193081886',
    100: '1235302947664171181',
    250: '1235301635035496548',
    500: '1235302113840599111'
}

def load_stats():

    with open('LitecoinCore/StatsFile.json', 'r') as file:
        data = json.load(file)
    return data['Stats']

async def update_roles(user_id, amount):

    guild = bot.get_guild(1234166898413797478)  
    member = guild.get_member(user_id)

    if member:
        for threshold, role_id in thresholds.items():
            role = guild.get_role(int(role_id))
            if amount >= threshold and role not in member.roles:
                await member.add_roles(role)
            elif amount < threshold and role in member.roles:
                await member.remove_roles(role)

@tasks.loop(minutes=25)
async def check_stats():

    stats = load_stats()
    for user_id, amount in stats.items():
        await update_roles(int(user_id), amount)



client.run("Discord BOT Token")



# All Channel IDS, Role IDS, etc... are not changed.
# Node I was using was Litecoin Core
